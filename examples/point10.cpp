// point10.cpp
// Test point10 stuff
//

#include "common/common.hpp"
#include "compressor.hpp"
#include "decompressor.hpp"

#include "las.hpp"
#include "encoder.hpp"
#include "decoder.hpp"
#include "formats.hpp"

#include <iostream>
#include <memory>

// First, create a simple class to capture data generated by the compressor, this could be anything
// as long as it confirms with the behaviour below.
//
struct SuchStream {
	SuchStream() : buf(), idx(0) {}

	void putBytes(const unsigned char* b, size_t len) {
		while(len --) {
			buf.push_back(*b++);
		}
	}

	void putByte(const unsigned char b) {
		buf.push_back(b);
	}

	unsigned char getByte() {
		return buf[idx++];
	}

	void getBytes(unsigned char *b, int len) {
		for (int i = 0 ; i < len ; i ++) {
			b[i] = getByte();
		}
	}

	std::vector<unsigned char> buf;	// cuz I'm ze faste
	size_t idx;
};

laszip::formats::las::point10 p; // free init to zero :)

int main() {
	// import namespaces to reduce typing
	//
	using namespace laszip;
	using namespace laszip::formats;


	// Create a record compressor for point10
	//
	record_compressor<
		field<las::point10>
	> compressor;

	int N = 1000;

	// Create an object of our stream to which the encoder will write
	//
	SuchStream s;

	// Instantiate the arithmetic encoder
	//
	encoders::arithmetic<SuchStream> encoder(s);

	// Encode some dummy data
	//
	for (int i = 0 ; i < N; i ++) {
		p.x = i;
		p.y = i + 1000;
		p.z = i + 10000;

		p.intensity = (unsigned short)(i + (1 << 15));
		p.return_number = (i >> 3) & 0x7;
		p.number_of_returns_of_given_pulse = i & 0x7;
		p.scan_direction_flag = i & 1;
		p.edge_of_flight_line = (i+1) & 1;
		p.classification = (unsigned char) i % 256;
		p.scan_angle_rank =  (unsigned char) i % 128;
		p.user_data = (i >> 4) % 256;
		p.point_source_ID = (i * 30) % (1 << 16);

		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor.compressWith(encoder, (const char*)&p);
	}

	// Finally terminate the encoder by calling done on it. This will flush out any pending data to output.
	//
	encoder.done();


	// Print some fun stuff about compression
	//
	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;

	// Setup record decompressor for point10
	//
	record_decompressor<
		field<las::point10>
	> decompressor;

	// Create a decoder same way as we did with the encoder
	//
	decoders::arithmetic<SuchStream> decoder(s);

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	for (int i = 0 ; i < N ; i ++) {
		// When we decompress data we need to provide where to decode stuff to
		//
		las::point10 p;
		decompressor.decompressWith(decoder, (char *)&p);

		// Finally make sure things match, otherwise bail
		if (p.x != i ||
			p.y != i + 1000 ||
			p.z != i + 10000 ||
			p.intensity != (unsigned short)(i + (1 << 15)) ||
			p.return_number != ((i >> 3) & 0x7) ||
			p.number_of_returns_of_given_pulse != (i & 0x7) ||
			p.scan_direction_flag != (i & 1) ||
			p.edge_of_flight_line != ((i+1) & 1) ||
			p.classification != ((unsigned char) i % 256) ||
			p.scan_angle_rank != ((unsigned char) i % 128) ||
			p.user_data != ((i >> 4) % 256) ||
			p.point_source_ID != ((i * 30) % (1 << 16)))
			throw std::runtime_error("Not matching");
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}
